<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/doc/manip2_reponses.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/doc/manip2_reponses.md" />
              <option name="updatedContent" value="# Laboratoire 2 - Manipulation 2 : Activité avec Fragments&#10;&#10;## Objectif&#10;&#10;Créer une Activité regroupant deux Fragments (CounterFragment et ColorFragment) avec une AppBar, en divisant l'écran en deux parties égales.&#10;&#10;## Implémentation&#10;&#10;### 1. Création de l'Activité&#10;&#10;Nous avons créé une nouvelle Activité `MainActivityFragment1.kt` qui héberge les deux fragments fournis.&#10;&#10;**Fichier : `MainActivityFragment1.kt`**&#10;&#10;```kotlin&#10;package ch.heigvd.iict.daa.template&#10;&#10;import android.os.Bundle&#10;import androidx.appcompat.app.AppCompatActivity&#10;import ch.heigvd.iict.daa.labo2.R&#10;import ch.heigvd.iict.daa.template.fragments.ColorFragment&#10;import ch.heigvd.iict.daa.template.fragments.CounterFragment&#10;&#10;class MainActivityFragment1 : AppCompatActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_main_fragment1)&#10;&#10;        if (savedInstanceState == null) {&#10;            supportFragmentManager.beginTransaction()&#10;                .add(R.id.counter_fragment_container, CounterFragment.newInstance())&#10;                .add(R.id.color_fragment_container, ColorFragment.newInstance())&#10;                .commit()&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;**Points clés de l'implémentation :**&#10;&#10;- Vérification de `savedInstanceState == null` pour éviter de recréer les fragments lors d'une rotation d'écran&#10;- Utilisation de `supportFragmentManager` pour gérer les transactions de fragments&#10;- Ajout des deux fragments dans leurs conteneurs respectifs via `add()`&#10;&#10;### 2. Création du Layout&#10;&#10;**Fichier : `activity_main_fragment1.xml`**&#10;&#10;Le layout utilise un `ConstraintLayout` avec les éléments suivants :&#10;&#10;1. **AppBar** : En haut de l'écran&#10;2. **Container pour CounterFragment** : Occupe 50% de l'espace disponible sous l'AppBar&#10;3. **Container pour ColorFragment** : Occupe les 50% restants&#10;&#10;```xml&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout &#10;    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&gt;&#10;&#10;    &lt;!-- Barre d'action --&gt;&#10;    &lt;com.google.android.material.appbar.AppBarLayout&#10;        android:id=&quot;@+id/appbarlayout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt;&#10;&#10;        &lt;androidx.appcompat.widget.Toolbar&#10;            android:id=&quot;@+id/toolbar&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;?attr/actionBarSize&quot;&#10;            android:background=&quot;?attr/colorPrimary&quot; /&gt;&#10;    &lt;/com.google.android.material.appbar.AppBarLayout&gt;&#10;&#10;    &lt;!-- Fragment Compteur --&gt;&#10;    &lt;FrameLayout&#10;        android:id=&quot;@+id/counter_fragment_container&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/appbarlayout&quot;&#10;        app:layout_constraintBottom_toTopOf=&quot;@id/color_fragment_container&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintHeight_percent=&quot;0.5&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;!-- Fragment Couleur --&gt;&#10;    &lt;FrameLayout&#10;        android:id=&quot;@+id/color_fragment_container&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/counter_fragment_container&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintHeight_percent=&quot;0.5&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;```&#10;&#10;**Choix techniques :**&#10;&#10;- Utilisation de `FrameLayout` comme conteneurs de fragments (pratique standard Android)&#10;- Division de l'écran en deux parties égales via des contraintes :&#10;  - `layout_height=&quot;0dp&quot;` avec contraintes top/bottom&#10;  - `layout_constraintHeight_percent=&quot;0.5&quot;` pour 50% de hauteur chacun&#10;- L'AppBar est placée en haut et ne compte pas dans la division 50/50&#10;&#10;### 3. Liste des manipulations effectuées&#10;&#10;1. ✅ Création du fichier `MainActivityFragment1.kt`&#10;2. ✅ Création du layout `activity_main_fragment1.xml`&#10;3. ✅ Ajout de l'AppBar dans le layout&#10;4. ✅ Création de deux conteneurs (FrameLayout) pour héberger les fragments&#10;5. ✅ Configuration des contraintes pour diviser l'écran en deux parties égales&#10;6. ✅ Ajout des fragments CounterFragment et ColorFragment via FragmentManager&#10;7. ✅ Vérification que les noms de packages correspondent dans les fragments fournis&#10;&#10;## Discussion et réponses aux questions&#10;&#10;### Question 1 : Restauration de l'état du ColorFragment sans sauvegarde explicite&#10;&#10;**Question :** Les deux Fragments fournis implémentent la restauration de leur état. Si on enlève la sauvegarde de l'état sur le ColorFragment, sa couleur sera tout de même restaurée. Comment pouvons-nous expliquer cela ?&#10;&#10;**Réponse :**&#10;&#10;La couleur du `ColorFragment` serait restaurée même sans implémentation explicite de `onSaveInstanceState()` grâce au mécanisme de **sauvegarde automatique des vues** d'Android.&#10;&#10;**Explication détaillée :**&#10;&#10;1. **Sauvegarde automatique des vues :** Android sauvegarde et restaure automatiquement l'état des vues qui ont un ID unique (`android:id`) et qui implémentent la sauvegarde d'état (comme `SeekBar`, `TextView`, `EditText`, etc.).&#10;&#10;2. **Dans le ColorFragment :** Les trois `SeekBar` (pour R, G, B) ont des IDs :&#10;   - `@+id/color_r`&#10;   - `@+id/color_g`&#10;   - `@+id/color_b`&#10;   &#10;   Leurs positions (progress) sont automatiquement sauvegardées et restaurées par Android.&#10;&#10;3. **Reconstitution de la couleur :** Lors de la restauration après rotation :&#10;   - Les `SeekBar` retrouvent automatiquement leurs valeurs&#10;   - Dans `onViewCreated()`, le listener `seekBarChangeListener` est réattaché&#10;   - Même si la variable `color` est réinitialisée, les `SeekBar` gardent leurs valeurs&#10;   - Le fond peut être recalculé en lisant les valeurs actuelles des `SeekBar`&#10;&#10;**Cependant**, il est recommandé de toujours implémenter `onSaveInstanceState()` pour :&#10;- Garantir un comportement cohérent&#10;- Éviter de dépendre du comportement automatique qui pourrait changer&#10;- Sauvegarder des données qui ne sont pas dans des vues&#10;&#10;### Question 2 : Restauration avec deux instances de CounterFragment&#10;&#10;**Question :** Si nous plaçons deux fois le CounterFragment dans l'Activité, nous aurons deux instances indépendantes de celui-ci. Comment est-ce que la restauration de l'état se passe en cas de rotation de l'écran ?&#10;&#10;**Réponse :**&#10;&#10;Android gère la restauration de l'état de multiples instances de fragments grâce à un système d'**identification unique** de chaque fragment.&#10;&#10;**Mécanisme de restauration :**&#10;&#10;1. **Identification des fragments :**&#10;   - Chaque fragment ajouté reçoit un identifiant unique automatique (ou un tag si fourni)&#10;   - Android associe le Bundle d'état sauvegardé à chaque fragment via cet identifiant&#10;   - L'ID du conteneur (`R.id.counter_fragment_container`) participe également à l'identification&#10;&#10;2. **Processus lors de la rotation :**&#10;   - **Avant rotation :** &#10;     - `onSaveInstanceState()` est appelé pour chaque fragment&#10;     - Chaque fragment sauvegarde son compteur dans son propre Bundle&#10;     - Android stocke ces Bundles séparément avec leurs identifiants respectifs&#10;   &#10;   - **Après rotation :**&#10;     - Android recrée automatiquement les fragments (pas besoin de vérifier `savedInstanceState == null`)&#10;     - Chaque fragment reçoit son propre Bundle sauvegardé&#10;     - Dans `onViewCreated()`, chaque fragment restaure sa propre valeur de compteur&#10;&#10;3. **Exemple avec deux CounterFragment :**&#10;   ```kotlin&#10;   // Dans l'activité&#10;   supportFragmentManager.beginTransaction()&#10;       .add(R.id.container1, CounterFragment.newInstance(), &quot;counter1&quot;)&#10;       .add(R.id.container2, CounterFragment.newInstance(), &quot;counter2&quot;)&#10;       .commit()&#10;   ```&#10;   &#10;   - Fragment 1 (container1) : compteur = 5&#10;   - Fragment 2 (container2) : compteur = 12&#10;   - Après rotation : chaque fragment conserve sa propre valeur&#10;&#10;4. **Clés de sauvegarde :**&#10;   - Même si les deux fragments utilisent la même clé `ARG_COUNTER` dans leur Bundle&#10;   - Les Bundles sont séparés au niveau du système Android&#10;   - Pas de conflit possible entre les instances&#10;&#10;**Conclusion :** La restauration fonctionne correctement car Android maintient une association unique entre chaque instance de fragment et son état sauvegardé, même s'il s'agit de multiples instances de la même classe.&#10;&#10;## Résultats&#10;&#10;✅ **Application fonctionnelle** avec :&#10;- Deux fragments affichés simultanément&#10;- Division de l'écran en deux parties égales&#10;- AppBar en haut de l'écran&#10;- Restauration correcte de l'état lors de la rotation d'écran :&#10;  - Le compteur conserve sa valeur&#10;  - La couleur sélectionnée est préservée&#10;&#10;## Remarques et améliorations possibles&#10;&#10;- Les fragments sont ajoutés uniquement si `savedInstanceState == null` pour éviter la duplication lors des rotations&#10;- Android recrée automatiquement les fragments lors des changements de configuration&#10;- Le système de FragmentManager gère la pile et la restauration des fragments&#10;- Pour une application plus complexe, on pourrait utiliser un ViewModel pour partager des données entre fragments et éviter la perte de données non sauvegardées&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>